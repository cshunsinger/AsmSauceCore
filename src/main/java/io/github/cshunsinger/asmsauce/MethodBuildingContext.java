package io.github.cshunsinger.asmsauce;

import io.github.cshunsinger.asmsauce.definitions.CompleteMethodDefinition;
import io.github.cshunsinger.asmsauce.definitions.ParamDefinition;
import io.github.cshunsinger.asmsauce.definitions.TypeDefinition;
import lombok.Getter;
import org.objectweb.asm.MethodVisitor;

import java.util.*;
import java.util.stream.Collectors;

/**
 * The context representing the state of the method being built which is present during the building of a method.
 * Every different method being generated is given it's own context to represent the state of that method's creation.
 */
@Getter
public class MethodBuildingContext {
    private static final ThreadLocal<MethodBuildingContext> CONTEXT = new ThreadLocal<>();

    /**
     * Fetches the currently active method building context for the current thread. The returned context will be the
     * last instantiated MethodBuildingContext instance since the last reset() call.
     * @return The currently active method building context if it exists.
     * @throws IllegalStateException If there is no currently active method building context.
     * @see #reset()
     */
    public static MethodBuildingContext context() {
        MethodBuildingContext buildingContext = CONTEXT.get();
        if(buildingContext == null)
            throw new IllegalStateException("Context must be accessed from within a method building scope.");

        return buildingContext;
    }

    /**
     * Resets the active method building context for the current thread. This method is called by the AsmClassBuilder
     * after it finishes building each method or constructor.
     * After this method is called, {@link MethodBuildingContext#context()} will throw an {@link IllegalStateException}
     * until a new context is started.
     * @see #context()
     */
    public static void reset() {
        CONTEXT.remove();
    }

    private static final Set<Class<?>> LARGE_LOCALS = Set.of(double.class, long.class);

    /**
     * @return The method visitor for writing the bytecode of the current method.
     */
    private final MethodVisitor methodVisitor;
    /**
     * @return The definition of the current method being built.
     */
    private final CompleteMethodDefinition currentMethod;
    /**
     * @return The context of the class being built which contains this method being built.
     */
    private final ClassBuildingContext classContext;
    /**
     * @return The list of local variable types. This list is used by this method building context to track the type of
     * each local variable or parameter.
     */
    private final List<TypeDefinition> localTypes;
    /**
     * @return A map containing the name of each named local variable mapped to the index of the local variable. If a
     * local variable or parameter in the current method is unnamed, then it will not have an entry in this map.
     */
    private final Map<String, Integer> localNames = new HashMap<>();
    /**
     * @return A Stack of types representing the JVM runtime stack. This stack should constantly match the expected stack
     * in the JVM when the generated bytecode is actually being executed.
     */
    private final Stack<TypeDefinition> typeStack = new Stack<>();
    /**
     * @return A stack of local variable indexes. The top element of this stack is the index of the first local variable
     * created inside of the current scope of Java code.
     */
    private final Stack<Integer> scopeStack = new Stack<>();

    /**
     * Creates a new method building context to track the method being built. If the method being built is an instance method,
     * then it is assumed that the parameters passed to this constructor will include the "this" parameter.
     * @param methodVisitor The low-level method visitor for producing the bytecode.
     * @param currentMethod A definition of the method being generated.
     * @param classContext The class context of the class that this method is being generated for.
     * @param parameters The parameters of this method being built. This list should include "this" as the first element
     *                   if this method being built is an instance method.
     */
    public MethodBuildingContext(MethodVisitor methodVisitor,
                                 CompleteMethodDefinition currentMethod,
                                 ClassBuildingContext classContext,
                                 List<ParamDefinition> parameters) {
        this.methodVisitor = methodVisitor;
        this.currentMethod = currentMethod;
        this.classContext = classContext;
        this.localTypes = new ArrayList<>();

        parameters.forEach(param -> {
            String name = param.getParamName();
            if(name == null)
                addLocalType(param.getParamType());
            else
                setLocalType(param.getParamName(), param.getParamType());
        });
        scopeStack.push(0);

        CONTEXT.set(this);
    }

    /**
     * Signals to this context that a new scope is being entered. This method should be called any time a new scope for
     * local variables is beginning, such as at the beginning of an if-block or while-loop body.
     */
    public void beginScope() {
        //The value pushed is essentially the index of the first local variable that will be visible in the new scope
        //Any locals with this index or higher will not be visible anymore once this scope ends.
        scopeStack.push(localTypes.size());
    }

    /**
     * Signals to this context that the code generation is leaving it's current scope, such as the end of a while-loop
     * body or if-block.
     * This will cause this context to remove any local variables which were created inside the scope while leaving
     * local variables created before entering the scope alone.
     */
    public void endScope() {
        int beginIndex = scopeStack.pop(); //The first local variable index for the scope being ended.

        //Remove all locals on or after the beginIndex as these locals are no longer visible since the scope is ending
        while(localTypes.size() > beginIndex) {
            localTypes.remove(localTypes.size() - 1);
        }

        //Remove any local variable names from the mapping if those locals are out of scope now
        localNames.entrySet()
            .stream()
            .filter(entry -> entry.getValue() >= beginIndex)
            .map(Map.Entry::getKey)
            .collect(Collectors.toSet())
            .forEach(localNames::remove);
    }

    /**
     * Peek the type of element on the top of the type stack. The type stack will not be modified.
     * @return The type at the top of the stack.
     */
    public TypeDefinition peekStack() {
        return typeStack.peek();
    }

    /**
     * Fetch the type of element on the top of the type stack. The type stack will have that element popped.
     * @return The type that was popped off the top of the type stack.
     * @see #popStack(int)
     */
    public TypeDefinition popStack() {
        return typeStack.pop();
    }

    /**
     * Pops zero or more elements off the top of the type stack.
     * @param numElements The number of elements to pop off the top of the type stack.
     * @throws EmptyStackException If numElements is greater than the current size of the type stack.
     * @see #popStack()
     */
    public void popStack(int numElements) {
        for(int i = 0; i < numElements; i++) {
            typeStack.pop();
        }
    }

    /**
     * Pushes a type onto the type stack.
     * @param type The type to push onto the type stack.
     * @return Returns the type element that was pushed to the type stack.
     */
    public TypeDefinition pushStack(TypeDefinition type) {
        return typeStack.push(type);
    }

    /**
     * Gets the current size of the type stack.
     * @return The current size of the type stack.
     * @see #isStackEmpty()
     */
    public int stackSize() {
        return typeStack.size();
    }

    /**
     * Gets whether or not the type stack is empty.
     * @return Returns true if the size of the type stack is 0, else returns false.
     * @see #stackSize()
     */
    public boolean isStackEmpty() {
        return typeStack.isEmpty();
    }

    /**
     * Gets the index of a named local variable.
     * @param localName The name of the local variable to look up.
     * @return The index of the local variable with the given name.
     * @throws IllegalStateException If no local variable exists with the given name.
     * @see #getLocalType(int)
     * @see #getLocalType(String)
     */
    public int getLocalIndex(String localName) {
        if(localNames.containsKey(localName))
            return localNames.get(localName);
        else
            throw new IllegalStateException("No local variable exists with the name " + localName + ".");
    }

    /**
     * Gets the type of a local variable at a given index.
     * @param index The index of the local variable to look up the type of.
     * @return The local variable type.
     * @throws IndexOutOfBoundsException If index is less than 0 or greater than the number of local variables.
     * @see #getLocalType(String)
     * @see #getLocalIndex(String)
     */
    public TypeDefinition getLocalType(int index) {
        return localTypes.get(index);
    }

    /**
     * Gets the type of a named local variable.
     * @param name The name of the local variable to look up.
     * @return The local variable type.
     * @throws IllegalStateException If no local variable exists with the given name.
     * @see #getLocalType(int)
     * @see #getLocalIndex(String)
     */
    public TypeDefinition getLocalType(String name) {
        return getLocalType(getLocalIndex(name));
    }

    /**
     * Adds a new local variable with a specified type. The local variable will be placed onto the end of the locals
     * list.
     * @param type The local variable's type.
     * @return The new index of the new unnamed local variable.
     * @see #numLocals()
     * @see #setLocalType(int, TypeDefinition)
     * @see #setLocalType(String, TypeDefinition)
     */
    public int addLocalType(TypeDefinition type) {
        int newIndex = localTypes.size();
        localTypes.add(type);

        if(LARGE_LOCALS.contains(type.getType()))
            localTypes.add(type);

        return newIndex;
    }

    /**
     * Sets a new type for a local variable at a specified index. If the index is equal to the number of local variables
     * that currently exist, a new local variable will be added. If the index is greater than the number of local
     * variables that currently exist, an exception will be thrown.
     * @param index The index of the local variable to update.
     * @param type The new type to set for the local variable.
     * @throws IndexOutOfBoundsException If index > numLocals
     * @see #numLocals()
     * @see #setLocalType(String, TypeDefinition)
     * @see #addLocalType(TypeDefinition)
     */
    public void setLocalType(int index, TypeDefinition type) {
        if(index == localTypes.size())
            addLocalType(type);
        else
            localTypes.set(index, type);

        if(LARGE_LOCALS.contains(type.getType())) {
            index++;
            if(index == localTypes.size())
                localTypes.add(type);
            else
                localTypes.set(index, type);
        }
    }

    /**
     * Sets the type of a named local variable. If no local variable exists with the given name, then a new named
     * local variable will be created automatically and assigned the provided type.
     * @param name The name of the local variable to create or update.
     * @param type The type to assign to the local variable.
     */
    public void setLocalType(String name, TypeDefinition type) {
        if(localNames.containsKey(name)) {
            int index = localNames.get(name);
            setLocalType(index, type);
        }
        else {
            int index = addLocalType(type);
            localNames.put(name, index);
        }
    }

    /**
     * The number of local variables that currently exist.
     * @return The current count of local variables.
     */
    public int numLocals() {
        return localTypes.size();
    }

    /**
     * Gets the return type of the method currently being built.
     * @return The return type.
     */
    public TypeDefinition returnType() {
        return currentMethod.getReturnType();
    }
}